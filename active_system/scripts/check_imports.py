#!/usr/bin/env python3
"""
Import errors checker for NeuroPETRIX
Otomatik import hatalarƒ± yakalama ve √ß√∂z√ºm √∂nerileri
"""

import ast
import sys
import os
from pathlib import Path
from typing import List, Dict, Set, Tuple
import importlib.util
import subprocess

class ImportChecker:
    def __init__(self):
        self.project_root = Path(__file__).parent.parent
        self.backend_path = self.project_root / "backend"
        self.errors = []
        self.warnings = []
        self.fixed_imports = []
        
        # Bilinen import sorunlarƒ± ve √ß√∂z√ºmleri
        self.import_fixes = {
            "backend.core.settings": "from backend.core.settings import settings",
            "backend.routers": "from backend.routers import router_name",
            "backend.services": "from backend.services import service_name",
            "backend.models": "from backend.models import model_name",
            "backend.core.auth": "from backend.core.auth import auth_function",
            "backend.core.database": "from backend.core.database import db_function",
        }

    def check_file_imports(self, file_path: Path) -> bool:
        """Tek bir dosyadaki import'larƒ± kontrol et"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # AST parse et
            try:
                tree = ast.parse(content)
            except SyntaxError as e:
                self.errors.append(f"‚ùå {file_path}: Syntax hatasƒ± - {e}")
                return False
            
            # Import'larƒ± topla
            imports = self._extract_imports(tree)
            
            # Her import'u kontrol et
            for import_info in imports:
                self._check_single_import(file_path, import_info)
            
            return len(self.errors) == 0
            
        except Exception as e:
            self.errors.append(f"‚ùå {file_path}: Dosya okuma hatasƒ± - {e}")
            return False

    def _extract_imports(self, tree: ast.AST) -> List[Dict]:
        """AST'den import'larƒ± √ßƒ±kar"""
        imports = []
        
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imports.append({
                        'type': 'import',
                        'module': alias.name,
                        'alias': alias.asname,
                        'line': node.lineno
                    })
            
            elif isinstance(node, ast.ImportFrom):
                module = node.module or ''
                for alias in node.names:
                    imports.append({
                        'type': 'from_import',
                        'module': module,
                        'name': alias.name,
                        'alias': alias.asname,
                        'line': node.lineno
                    })
        
        return imports

    def _check_single_import(self, file_path: Path, import_info: Dict):
        """Tek bir import'u kontrol et"""
        line_num = import_info['line']
        
        if import_info['type'] == 'import':
            module = import_info['module']
            self._check_module_import(file_path, module, line_num)
        
        elif import_info['type'] == 'from_import':
            module = import_info['module']
            name = import_info['name']
            self._check_from_import(file_path, module, name, line_num)

    def _check_module_import(self, file_path: Path, module: str, line_num: int):
        """Module import'unu kontrol et"""
        # Backend i√ßi import'lar
        if module.startswith('backend.'):
            if not self._is_backend_import_valid(module):
                self.errors.append(
                    f"‚ùå {file_path}:{line_num} Ge√ßersiz backend import - {module}"
                )
                self._suggest_fix(file_path, module, line_num)
        
        # External library import'lar
        elif not self._is_external_import_valid(module):
            self.warnings.append(
                f"‚ö†Ô∏è  {file_path}:{line_num} Potansiyel import sorunu - {module}"
            )

    def _check_from_import(self, file_path: Path, module: str, name: str, line_num: int):
        """From import'unu kontrol et"""
        if module.startswith('backend.'):
            if not self._is_backend_from_import_valid(module, name):
                self.errors.append(
                    f"‚ùå {file_path}:{line_num} Ge√ßersiz backend from import - {module}.{name}"
                )
                self._suggest_fix(file_path, f"{module}.{name}", line_num)

    def _is_backend_import_valid(self, module: str) -> bool:
        """Backend import'unun ge√ßerli olup olmadƒ±ƒüƒ±nƒ± kontrol et"""
        # Backend dizin yapƒ±sƒ±nƒ± kontrol et
        module_path = self.backend_path / module.replace('backend.', '').replace('.', '/')
        
        # __init__.py dosyasƒ± var mƒ±?
        init_file = module_path / "__init__.py"
        if init_file.exists():
            return True
        
        # Python dosyasƒ± var mƒ±?
        py_file = module_path.with_suffix('.py')
        if py_file.exists():
            return True
        
        # Alt dizin var mƒ±?
        if module_path.is_dir():
            return True
        
        return False

    def _is_backend_from_import_valid(self, module: str, name: str) -> bool:
        """Backend from import'unun ge√ßerli olup olmadƒ±ƒüƒ±nƒ± kontrol et"""
        if not self._is_backend_import_valid(module):
            return False
        
        # Mod√ºl√º import etmeyi dene
        try:
            module_path = self.backend_path / module.replace('backend.', '').replace('.', '/')
            
            if module_path.is_dir():
                # Dizin ise __init__.py'yi kontrol et
                init_file = module_path / "__init__.py"
                if init_file.exists():
                    spec = importlib.util.spec_from_file_location(module, init_file)
                    if spec and spec.loader:
                        module_obj = importlib.util.module_from_spec(spec)
                        spec.loader.exec_module(module_obj)
                        return hasattr(module_obj, name)
            
            elif module_path.with_suffix('.py').exists():
                # Python dosyasƒ± ise
                py_file = module_path.with_suffix('.py')
                spec = importlib.util.spec_from_file_location(module, py_file)
                if spec and spec.loader:
                    module_obj = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module_obj)
                    return hasattr(module_obj, name)
        
        except Exception:
            pass
        
        return False

    def _is_external_import_valid(self, module: str) -> bool:
        """External library import'unun ge√ßerli olup olmadƒ±ƒüƒ±nƒ± kontrol et"""
        try:
            # Standart library kontrol√º
            if module in sys.builtin_module_names:
                return True
            
            # Installed package kontrol√º
            importlib.import_module(module)
            return True
        
        except ImportError:
            return False

    def _suggest_fix(self, file_path: Path, import_str: str, line_num: int):
        """Import hatasƒ± i√ßin √ß√∂z√ºm √∂ner"""
        if import_str in self.import_fixes:
            fix = self.import_fixes[import_str]
            self.fixed_imports.append({
                'file': file_path,
                'line': line_num,
                'original': import_str,
                'suggested': fix
            })

    def check_all_backend_files(self) -> bool:
        """T√ºm backend dosyalarƒ±nƒ± kontrol et"""
        print("üîç Backend import'larƒ± kontrol ediliyor...")
        
        if not self.backend_path.exists():
            self.errors.append(f"‚ùå Backend dizini bulunamadƒ±: {self.backend_path}")
            return False
        
        # T√ºm Python dosyalarƒ±nƒ± bul
        python_files = list(self.backend_path.rglob("*.py"))
        
        print(f"üìÅ {len(python_files)} Python dosyasƒ± bulundu")
        
        success_count = 0
        for py_file in python_files:
            if self.check_file_imports(py_file):
                success_count += 1
        
        print(f"‚úÖ {success_count}/{len(python_files)} dosya ba≈üarƒ±yla kontrol edildi")
        
        return len(self.errors) == 0

    def check_circular_imports(self) -> bool:
        """Circular import'larƒ± kontrol et"""
        print("üîÑ Circular import'lar kontrol ediliyor...")
        
        # Basit circular import kontrol√º
        # Bu daha geli≈ümi≈ü bir implementasyon gerektirir
        # ≈ûimdilik temel kontrol yapƒ±yoruz
        
        return True

    def generate_fix_suggestions(self) -> str:
        """√á√∂z√ºm √∂nerileri olu≈ütur"""
        if not self.fixed_imports:
            return "‚úÖ Otomatik √ß√∂z√ºm √∂nerisi bulunamadƒ±"
        
        suggestions = []
        suggestions.append("üîß √ñNERƒ∞LEN √á√ñZ√úMLER:")
        suggestions.append("=" * 50)
        
        for fix in self.fixed_imports:
            suggestions.append(f"üìÑ {fix['file']}:{fix['line']}")
            suggestions.append(f"  ‚ùå {fix['original']}")
            suggestions.append(f"  ‚úÖ {fix['suggested']}")
            suggestions.append("")
        
        return "\n".join(suggestions)

    def generate_report(self) -> str:
        """Kontrol raporu olu≈ütur"""
        report = []
        report.append("=" * 60)
        report.append("üîç NEUROPETRIX IMPORT CHECKER RAPORU")
        report.append("=" * 60)
        
        if self.errors:
            report.append(f"\n‚ùå HATALAR ({len(self.errors)}):")
            for error in self.errors:
                report.append(f"  {error}")
        
        if self.warnings:
            report.append(f"\n‚ö†Ô∏è  UYARILAR ({len(self.warnings)}):")
            for warning in self.warnings:
                report.append(f"  {warning}")
        
        if self.fixed_imports:
            report.append(f"\n{self.generate_fix_suggestions()}")
        
        if not self.errors and not self.warnings:
            report.append("\n‚úÖ T√ºm import'lar ba≈üarƒ±yla kontrol edildi!")
        
        report.append(f"\nüìä √ñZET:")
        report.append(f"  - Hata: {len(self.errors)}")
        report.append(f"  - Uyarƒ±: {len(self.warnings)}")
        report.append(f"  - √á√∂z√ºm √∂nerisi: {len(self.fixed_imports)}")
        report.append(f"  - Durum: {'‚úÖ BA≈ûARILI' if len(self.errors) == 0 else '‚ùå BA≈ûARISIZ'}")
        
        return "\n".join(report)

def main():
    """Ana fonksiyon"""
    checker = ImportChecker()
    
    # Backend dosyalarƒ±nƒ± kontrol et
    backend_ok = checker.check_all_backend_files()
    
    # Circular import'larƒ± kontrol et
    circular_ok = checker.check_circular_imports()
    
    # Rapor olu≈ütur
    report = checker.generate_report()
    print(report)
    
    # Exit code
    if backend_ok and circular_ok:
        sys.exit(0)
    else:
        sys.exit(1)

if __name__ == "__main__":
    main()
